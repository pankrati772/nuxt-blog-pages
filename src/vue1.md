+ 网络优化
+ 页面渲染优化
+ JS优化
+ 图片优化
+ Webpack优化
+ react优化
+ vue优化





## 网络优化 
#### DNS预解析
:::info
link标签的rel属性设置 dns-prefetch，提前获取域名对应的IP地址

:::

#### 使用缓存


#### 使用cdn（内容分发网络）
:::info
<font style="color:rgb(65, 44, 12);">用户与服务器的物理距离对响应时间也有影响。</font>

<font style="color:rgb(65, 44, 12);">内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器</font>

:::

#### 压缩响应
:::info
压缩组件通过减少HTTP请求产生的响应包的大小 ，从而降低传输时间的方式提高性能。从HTTP 1.1 开始，WEB客户端可以通过HTTP请求中的Accept-Encoding 头来标识对压缩的支持（这个请求头会列出一系列的压缩方法）

如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端使用哪种方法进行的压缩



目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应理论上都值得被压缩）。但是，图片和 PDF 文件不应该被压缩，因为它们本来已经被压缩了。



:::

#### 使用多个域名
:::info
<font style="color:rgb(65, 44, 12);">Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。</font>

:::



#### 避免图片SRC为空
:::info
虽然src属性为空字符串，但是浏览器仍然会像服务器发起一个HTTP请求

<font style="color:rgb(65, 44, 12);">IE 向页面所在的目录发送请求； Safari、Chrome、Firefox 向页面本身发送请求； Opera 不执行任何操作。</font>

:::



## 页面渲染优化
Webkit渲染引擎流程：

+ 处理HTML并构建DOM树
+ 处理 CSS 构建 CSS 规则树 (CSSOM)
+ DOM Tree 和 CSSOM Tree 合成一棵渲染树 Render Tree
+ 根据渲染树来布局， 计算每个节点位置
+ 调用GPU绘制， 合成图层，显示在屏幕上



#### 避免css阻塞
:::info
css 影响 render Tree 的构建，会阻塞页面的渲染，因此应该将css资源加载优化

:::



#### 降低css选择器的复杂度
:::info
浏览器读取选择器，遵循的原则是从选择器的右边到左边读取

+ 减少嵌套：最多不要超过三层，并且后代选择器的开销比较高，慎重使用
+ 避免使用通配符，对用到的元素匹配即可
+ 利用继承，避免重复匹配和定义
+ 正确使用类选择器和id选择器

:::

#### 避免使用css表达式
:::info
css表达式会被频繁地计算 

:::





#### 使用外链式的js和css
:::info
在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。

:::



#### 使用字体图标iconfont代替图片图标
:::info
+ 图片会增加网络请求次数，从而拖慢页面加载时间
+ iconfont可以很好的缩放并且不会添加额外的请求

:::

#### 首屏加载优化
:::info
+ 使用骨架屏或者动画优化用户体验
+ 资源按需加载，首页不需要的资源延迟加载

:::

#### 减少重绘和回流
:::info
+ 增加多个节点使用documentFragment：不是真实的dom的部分，不会引起重绘和回流
+ 用translate代替top  （定位的情况下 css）
+ 使用 visibility 替换 display：none  前者只会引起重绘，后者会引起回流（改变布局） 用opacity代替 visiability  ，visiability会触发重绘，但是 opacity不会
+ 把  dom 里先后修改
+ 不要把dom节点的属性值放在一个循环里当作循环变量
+ 尽量少用table布局，table布局每次单元格有变动都会进行真个table的回流重绘
+ 最好别频繁去操作Dom节点，把需要操作的样式，提前写成class，之后需要修改，只需要修改一次。
+ 动画实现的速度选择，动画速度越快，回流次数越多，也可以使用 requestAnimationFrame
+ 每次访问DOM的偏移量属性的时候，例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最取完做个缓存。更加不要for循环中访问DOM偏移量属性，而且使用的时候，最好定义一个变量，把要需要的值赋值进去，进行值缓存，把回流重绘的次数减少；
+ 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。

:::



## JS中的性能优化
### 使用事件委托


### 防抖和节流


### 尽量不要使用JS动画
:::info
css动画和canvas动画都比js动画性能要好

:::



### 多线程
:::info
复杂的计算开启webWorker进行计算，避免页面假死

:::

### 计算结果缓存
:::info
减少运算次数，比如vue中的computed

:::



## 图片的优化
### 雪碧图
:::info
借助减少http请求次数进行优化

:::

### 图片懒加载
:::info
在图片即将进入可视区域的时候进行加载

:::



## 使用css3替代图片
:::info
很多图片使用css效果（渐变、阴影）能够画出来，这种情况使用css3会更好

:::

